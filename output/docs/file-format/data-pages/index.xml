<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Parquet – Data Pages</title><link>/docs/file-format/data-pages/</link><description>Recent content in Data Pages on Apache Parquet</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/docs/file-format/data-pages/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Compression</title><link>/docs/file-format/data-pages/compression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/compression/</guid><description>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>Parquet allows the data block inside dictionary pages and data pages to
be compressed for better space efficiency. The Parquet format supports
several compression covering different areas in the compression ratio /
processing cost spectrum.&lt;/p>
&lt;p>The detailed specifications of compression codecs are maintained externally
by their respective authors or maintainers, which we reference hereafter.&lt;/p>
&lt;p>For all compression codecs except the deprecated &lt;code>LZ4&lt;/code> codec, the raw data
of a (data or dictionary) page is fed &lt;em>as-is&lt;/em> to the underlying compression
library, without any additional framing or padding. The information required
for precise allocation of compressed and decompressed buffers is written
in the &lt;code>PageHeader&lt;/code> struct.&lt;/p>
&lt;h2 id="codecs">Codecs&lt;/h2>
&lt;h3 id="uncompressed">UNCOMPRESSED&lt;/h3>
&lt;p>No-op codec. Data is left uncompressed.&lt;/p>
&lt;h3 id="snappy">SNAPPY&lt;/h3>
&lt;p>A codec based on the
&lt;a href="https://github.com/google/snappy/blob/master/format_description.txt">Snappy compression format&lt;/a>.
If any ambiguity arises when implementing this format, the implementation
provided by Google Snappy &lt;a href="https://github.com/google/snappy/">library&lt;/a>
is authoritative.&lt;/p>
&lt;h3 id="gzip">GZIP&lt;/h3>
&lt;p>A codec based on the GZIP format (not the closely-related &amp;ldquo;zlib&amp;rdquo; or &amp;ldquo;deflate&amp;rdquo;
formats) defined by &lt;a href="https://tools.ietf.org/html/rfc1952">RFC 1952&lt;/a>.
If any ambiguity arises when implementing this format, the implementation
provided by the &lt;a href="https://zlib.net/">zlib compression library&lt;/a> is authoritative.&lt;/p>
&lt;p>Readers should support reading pages containing multiple GZIP members, however,
as this has historically not been supported by all implementations, it is recommended
that writers refrain from creating such pages by default for better interoperability.&lt;/p>
&lt;h3 id="lzo">LZO&lt;/h3>
&lt;p>A codec based on or interoperable with the
&lt;a href="http://www.oberhumer.com/opensource/lzo/">LZO compression library&lt;/a>.&lt;/p>
&lt;h3 id="brotli">BROTLI&lt;/h3>
&lt;p>A codec based on the Brotli format defined by
&lt;a href="https://tools.ietf.org/html/rfc7932">RFC 7932&lt;/a>.
If any ambiguity arises when implementing this format, the implementation
provided by the &lt;a href="https://github.com/google/brotli">Brotli compression library&lt;/a>
is authoritative.&lt;/p>
&lt;h3 id="lz4">LZ4&lt;/h3>
&lt;p>A &lt;strong>deprecated&lt;/strong> codec loosely based on the LZ4 compression algorithm,
but with an additional undocumented framing scheme. The framing is part
of the original Hadoop compression library and was historically copied
first in parquet-mr, then emulated with mixed results by parquet-cpp.&lt;/p>
&lt;p>It is strongly suggested that implementors of Parquet writers deprecate
this compression codec in their user-facing APIs, and advise users to
switch to the newer, interoperable &lt;code>LZ4_RAW&lt;/code> codec.&lt;/p>
&lt;h3 id="zstd">ZSTD&lt;/h3>
&lt;p>A codec based on the Zstandard format defined by
&lt;a href="https://tools.ietf.org/html/rfc8478">RFC 8478&lt;/a>. If any ambiguity arises
when implementing this format, the implementation provided by the
&lt;a href="https://facebook.github.io/zstd/">ZStandard compression library&lt;/a>
is authoritative.&lt;/p>
&lt;h3 id="lz4_raw">LZ4_RAW&lt;/h3>
&lt;p>A codec based on the &lt;a href="https://github.com/lz4/lz4/blob/dev/doc/lz4_Block_format.md">LZ4 block format&lt;/a>.
If any ambiguity arises when implementing this format, the implementation
provided by the &lt;a href="http://www.lz4.org/">LZ4 compression library&lt;/a> is authoritative.&lt;/p></description></item><item><title>Docs: Encodings</title><link>/docs/file-format/data-pages/encodings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/encodings/</guid><description>
&lt;p>&lt;a name="PLAIN">&lt;/a>&lt;/p>
&lt;h3 id="plain-plain--0">Plain: (PLAIN = 0)&lt;/h3>
&lt;p>Supported Types: all&lt;/p>
&lt;p>This is the plain encoding that must be supported for types. It is
intended to be the simplest encoding. Values are encoded back to back.&lt;/p>
&lt;p>The plain encoding is used whenever a more efficient encoding can not be used. It
stores the data in the following format:&lt;/p>
&lt;ul>
&lt;li>BOOLEAN: &lt;a href="/docs/file-format/data-pages/encodings/#BITPACKED">Bit Packed&lt;/a>, LSB first&lt;/li>
&lt;li>INT32: 4 bytes little endian&lt;/li>
&lt;li>INT64: 8 bytes little endian&lt;/li>
&lt;li>INT96: 12 bytes little endian (deprecated)&lt;/li>
&lt;li>FLOAT: 4 bytes IEEE little endian&lt;/li>
&lt;li>DOUBLE: 8 bytes IEEE little endian&lt;/li>
&lt;li>BYTE_ARRAY: length in 4 bytes little endian followed by the bytes contained in the array&lt;/li>
&lt;li>FIXED_LEN_BYTE_ARRAY: the bytes contained in the array&lt;/li>
&lt;/ul>
&lt;p>For native types, this outputs the data as little endian. Floating
point types are encoded in IEEE.&lt;/p>
&lt;p>For the byte array type, it encodes the length as a 4 byte little
endian, followed by the bytes.&lt;/p>
&lt;h3 id="dictionary-encoding-plain_dictionary--2-and-rle_dictionary--8">Dictionary Encoding (PLAIN_DICTIONARY = 2 and RLE_DICTIONARY = 8)&lt;/h3>
&lt;p>The dictionary encoding builds a dictionary of values encountered in a given column. The
dictionary will be stored in a dictionary page per column chunk. The values are stored as integers
using the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/Bit-Packing Hybrid&lt;/a> encoding. If the dictionary grows too big, whether in size
or number of distinct values, the encoding will fall back to the plain encoding. The dictionary page is
written first, before the data pages of the column chunk.&lt;/p>
&lt;p>Dictionary page format: the entries in the dictionary using the &lt;a href="/docs/file-format/data-pages/encodings/#PLAIN">plain&lt;/a> encoding.&lt;/p>
&lt;p>Data page format: the bit width used to encode the entry ids stored as 1 byte (max bit width = 32),
followed by the values encoded using RLE/Bit packed described above (with the given bit width).&lt;/p>
&lt;p>Using the PLAIN_DICTIONARY enum value is deprecated in the Parquet 2.0 specification. Prefer using RLE_DICTIONARY
in a data page and PLAIN in a dictionary page for Parquet 2.0+ files.&lt;/p>
&lt;p>&lt;a name="RLE">&lt;/a>&lt;/p>
&lt;h3 id="run-length-encoding--bit-packing-hybrid-rle--3">Run Length Encoding / Bit-Packing Hybrid (RLE = 3)&lt;/h3>
&lt;p>This encoding uses a combination of bit-packing and run length encoding to more efficiently store repeated values.&lt;/p>
&lt;p>The grammar for this encoding looks like this, given a fixed bit-width known in advance:&lt;/p>
&lt;pre tabindex="0">&lt;code>rle-bit-packed-hybrid: &amp;lt;length&amp;gt; &amp;lt;encoded-data&amp;gt;
// length is not always prepended, please check the table below for more detail
length := length of the &amp;lt;encoded-data&amp;gt; in bytes stored as 4 bytes little endian (unsigned int32)
encoded-data := &amp;lt;run&amp;gt;*
run := &amp;lt;bit-packed-run&amp;gt; | &amp;lt;rle-run&amp;gt;
bit-packed-run := &amp;lt;bit-packed-header&amp;gt; &amp;lt;bit-packed-values&amp;gt;
bit-packed-header := varint-encode(&amp;lt;bit-pack-scaled-run-len&amp;gt; &amp;lt;&amp;lt; 1 | 1)
// we always bit-pack a multiple of 8 values at a time, so we only store the number of values / 8
bit-pack-scaled-run-len := (bit-packed-run-len) / 8
bit-packed-run-len := *see 3 below*
bit-packed-values := *see 1 below*
rle-run := &amp;lt;rle-header&amp;gt; &amp;lt;repeated-value&amp;gt;
rle-header := varint-encode( (rle-run-len) &amp;lt;&amp;lt; 1)
rle-run-len := *see 3 below*
repeated-value := value that is repeated, using a fixed-width of round-up-to-next-byte(bit-width)
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>The bit-packing here is done in a different order than the one in the &lt;a href="/docs/file-format/data-pages/encodings/#BITPACKED">deprecated bit-packing&lt;/a> encoding.
The values are packed from the least significant bit of each byte to the most significant bit,
though the order of the bits in each value remains in the usual order of most significant to least
significant. For example, to pack the same values as the example in the deprecated encoding above:&lt;/p>
&lt;p>The numbers 1 through 7 using bit width 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>dec value: 0 1 2 3 4 5 6 7
bit value: 000 001 010 011 100 101 110 111
bit label: ABC DEF GHI JKL MNO PQR STU VWX
&lt;/code>&lt;/pre>&lt;p>would be encoded like this where spaces mark byte boundaries (3 bytes):&lt;/p>
&lt;pre tabindex="0">&lt;code>bit value: 10001000 11000110 11111010
bit label: HIDEFABC RMNOJKLG VWXSTUPQ
&lt;/code>&lt;/pre>&lt;p>The reason for this packing order is to have fewer word-boundaries on little-endian hardware
when deserializing more than one byte at at time. This is because 4 bytes can be read into a
32 bit register (or 8 bytes into a 64 bit register) and values can be unpacked just by
shifting and ORing with a mask. (to make this optimization work on a big-endian machine,
you would have to use the ordering used in the &lt;a href="/docs/file-format/data-pages/encodings/#BITPACKED">deprecated bit-packing&lt;/a> encoding)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>varint-encode() is ULEB-128 encoding, see &lt;a href="https://en.wikipedia.org/wiki/LEB128">https://en.wikipedia.org/wiki/LEB128&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bit-packed-run-len and rle-run-len must be in the range [1, 2&lt;sup>31&lt;/sup> - 1].
This means that a Parquet implementation can always store the run length in a signed
32-bit integer. This length restriction was not part of the Parquet 2.5.0 and earlier
specifications, but longer runs were not readable by the most common Parquet
implementations so, in practice, were not safe for Parquet writers to emit.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Note that the RLE encoding method is only supported for the following types of
data:&lt;/p>
&lt;ul>
&lt;li>Repetition and definition levels&lt;/li>
&lt;li>Dictionary indices&lt;/li>
&lt;li>Boolean values in data pages, as an alternative to PLAIN encoding&lt;/li>
&lt;/ul>
&lt;p>Whether prepending the four-byte &lt;code>length&lt;/code> to the &lt;code>encoded-data&lt;/code> is summarized as the table below:&lt;/p>
&lt;pre tabindex="0">&lt;code>+--------------+------------------------+-----------------+
| Page kind | RLE-encoded data kind | Prepend length? |
+--------------+------------------------+-----------------+
| Data page v1 | Definition levels | Y |
| | Repetition levels | Y |
| | Dictionary indices | N |
| | Boolean values | Y |
+--------------+------------------------+-----------------+
| Data page v2 | Definition levels | N |
| | Repetition levels | N |
| | Dictionary indices | N |
| | Boolean values | Y |
+--------------+------------------------+-----------------+
&lt;/code>&lt;/pre>&lt;p>&lt;a name="BITPACKED">&lt;/a>&lt;/p>
&lt;h3 id="bit-packed-deprecated-bit_packed--4">Bit-packed (Deprecated) (BIT_PACKED = 4)&lt;/h3>
&lt;p>This is a bit-packed only encoding, which is deprecated and will be replaced by the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/bit-packing&lt;/a> hybrid encoding.
Each value is encoded back to back using a fixed width.
There is no padding between values (except for the last byte, which is padded with 0s).
For example, if the max repetition level was 3 (2 bits) and the max definition level as 3
(2 bits), to encode 30 values, we would have 30 * 2 = 60 bits = 8 bytes.&lt;/p>
&lt;p>This implementation is deprecated because the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/bit-packing&lt;/a> hybrid is a superset of this implementation.
For compatibility reasons, this implementation packs values from the most significant bit to the least significant bit,
which is not the same as the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/bit-packing&lt;/a> hybrid.&lt;/p>
&lt;p>For example, the numbers 1 through 7 using bit width 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>dec value: 0 1 2 3 4 5 6 7
bit value: 000 001 010 011 100 101 110 111
bit label: ABC DEF GHI JKL MNO PQR STU VWX
&lt;/code>&lt;/pre>&lt;p>would be encoded like this where spaces mark byte boundaries (3 bytes):&lt;/p>
&lt;pre tabindex="0">&lt;code>bit value: 00000101 00111001 01110111
bit label: ABCDEFGH IJKLMNOP QRSTUVWX
&lt;/code>&lt;/pre>&lt;p>Note that the BIT_PACKED encoding method is only supported for encoding
repetition and definition levels.&lt;/p>
&lt;p>&lt;a name="DELTAENC">&lt;/a>&lt;/p>
&lt;h3 id="delta-encoding-delta_binary_packed--5">Delta Encoding (DELTA_BINARY_PACKED = 5)&lt;/h3>
&lt;p>Supported Types: INT32, INT64&lt;/p>
&lt;p>This encoding is adapted from the Binary packing described in
&lt;a href="http://arxiv.org/pdf/1209.2137v5.pdf">&amp;ldquo;Decoding billions of integers per second through vectorization&amp;rdquo;&lt;/a>
by D. Lemire and L. Boytsov.&lt;/p>
&lt;p>In delta encoding we make use of variable length integers for storing various
numbers (not the deltas themselves). For unsigned values, we use ULEB128,
which is the unsigned version of LEB128 (&lt;a href="https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128)">https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128)&lt;/a>.
For signed values, we use zigzag encoding (&lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#signed-integers">https://developers.google.com/protocol-buffers/docs/encoding#signed-integers&lt;/a>)
to map negative values to positive ones and apply ULEB128 on the result.&lt;/p>
&lt;p>Delta encoding consists of a header followed by blocks of delta encoded values
binary packed. Each block is made of miniblocks, each of them binary packed with its own bit width.&lt;/p>
&lt;p>The header is defined as follows:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;block size in values&amp;gt; &amp;lt;number of miniblocks in a block&amp;gt; &amp;lt;total value count&amp;gt; &amp;lt;first value&amp;gt;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>the block size is a multiple of 128; it is stored as a ULEB128 int&lt;/li>
&lt;li>the miniblock count per block is a divisor of the block size such that their
quotient, the number of values in a miniblock, is a multiple of 32; it is
stored as a ULEB128 int&lt;/li>
&lt;li>the total value count is stored as a ULEB128 int&lt;/li>
&lt;li>the first value is stored as a zigzag ULEB128 int&lt;/li>
&lt;/ul>
&lt;p>Each block contains&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;min delta&amp;gt; &amp;lt;list of bitwidths of miniblocks&amp;gt; &amp;lt;miniblocks&amp;gt;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>the min delta is a zigzag ULEB128 int (we compute a minimum as we need
positive integers for bit packing)&lt;/li>
&lt;li>the bitwidth of each block is stored as a byte&lt;/li>
&lt;li>each miniblock is a list of bit packed ints according to the bit width
stored at the begining of the block&lt;/li>
&lt;/ul>
&lt;p>To encode a block, we will:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Compute the differences between consecutive elements. For the first
element in the block, use the last element in the previous block or, in
the case of the first block, use the first value of the whole sequence,
stored in the header.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Compute the frame of reference (the minimum of the deltas in the block).
Subtract this min delta from all deltas in the block. This guarantees that
all values are non-negative.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Encode the frame of reference (min delta) as a zigzag ULEB128 int followed
by the bit widths of the miniblocks and the delta values (minus the min
delta) bit-packed per miniblock.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Having multiple blocks allows us to adapt to changes in the data by changing
the frame of reference (the min delta) which can result in smaller values
after the subtraction which, again, means we can store them with a lower bit width.&lt;/p>
&lt;p>If there are not enough values to fill the last miniblock, we pad the miniblock
so that its length is always the number of values in a full miniblock multiplied
by the bit width. The values of the padding bits should be zero, but readers
must accept paddings consisting of arbitrary bits as well.&lt;/p>
&lt;p>If, in the last block, less than &lt;code>&amp;lt;number of miniblocks in a block&amp;gt;&lt;/code>
miniblocks are needed to store the values, the bytes storing the bit widths
of the unneeded miniblocks are still present, their value should be zero,
but readers must accept arbitrary values as well. There are no additional
padding bytes for the miniblock bodies though, as if their bit widths were 0
(regardless of the actual byte values). The reader knows when to stop reading
by keeping track of the number of values read.&lt;/p>
&lt;p>Subtractions in steps 1) and 2) may incur signed arithmetic overflow, and so
will the corresponding additions when decoding. Overflow should be allowed
and handled as wrapping around in 2&amp;rsquo;s complement notation so that the original
values are correctly restituted. This may require explicit care in some programming
languages (for example by doing all arithmetic in the unsigned domain).&lt;/p>
&lt;p>The following examples use 8 as the block size to keep the examples short,
but in real cases it would be invalid.&lt;/p>
&lt;h4 id="example-1">Example 1&lt;/h4>
&lt;p>1, 2, 3, 4, 5&lt;/p>
&lt;p>After step 1), we compute the deltas as:&lt;/p>
&lt;p>1, 1, 1, 1&lt;/p>
&lt;p>The minimum delta is 1 and after step 2, the relative deltas become:&lt;/p>
&lt;p>0, 0, 0, 0&lt;/p>
&lt;p>The final encoded data is:&lt;/p>
&lt;p>header:
8 (block size), 1 (miniblock count), 5 (value count), 1 (first value)&lt;/p>
&lt;p>block:
1 (minimum delta), 0 (bitwidth), (no data needed for bitwidth 0)&lt;/p>
&lt;h4 id="example-2">Example 2&lt;/h4>
&lt;p>7, 5, 3, 1, 2, 3, 4, 5, the deltas would be&lt;/p>
&lt;p>-2, -2, -2, 1, 1, 1, 1&lt;/p>
&lt;p>The minimum is -2, so the relative deltas are:&lt;/p>
&lt;p>0, 0, 0, 3, 3, 3, 3&lt;/p>
&lt;p>The encoded data is&lt;/p>
&lt;p>header:
8 (block size), 1 (miniblock count), 8 (value count), 7 (first value)&lt;/p>
&lt;p>block:
-2 (minimum delta), 2 (bitwidth), 00000011111111b (0,0,0,3,3,3,3 packed on 2 bits)&lt;/p>
&lt;h4 id="characteristics">Characteristics&lt;/h4>
&lt;p>This encoding is similar to the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/bit-packing&lt;/a> encoding. However the &lt;a href="/docs/file-format/data-pages/encodings/#RLE">RLE/bit-packing&lt;/a> encoding is specifically used when the range of ints is small over the entire page, as is true of repetition and definition levels. It uses a single bit width for the whole page.
The delta encoding algorithm described above stores a bit width per miniblock and is less sensitive to variations in the size of encoded integers. It is also somewhat doing RLE encoding as a block containing all the same values will be bit packed to a zero bit width thus being only a header.&lt;/p>
&lt;h3 id="delta-length-byte-array-delta_length_byte_array--6">Delta-length byte array: (DELTA_LENGTH_BYTE_ARRAY = 6)&lt;/h3>
&lt;p>Supported Types: BYTE_ARRAY&lt;/p>
&lt;p>This encoding is always preferred over PLAIN for byte array columns.&lt;/p>
&lt;p>For this encoding, we will take all the byte array lengths and encode them using delta
encoding (DELTA_BINARY_PACKED). The byte array data follows all of the length data just
concatenated back to back. The expected savings is from the cost of encoding the lengths
and possibly better compression in the data (it is no longer interleaved with the lengths).&lt;/p>
&lt;p>The data stream looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;Delta Encoded Lengths&amp;gt; &amp;lt;Byte Array Data&amp;gt;
&lt;/code>&lt;/pre>&lt;p>For example, if the data was &amp;ldquo;Hello&amp;rdquo;, &amp;ldquo;World&amp;rdquo;, &amp;ldquo;Foobar&amp;rdquo;, &amp;ldquo;ABCDEF&amp;rdquo;&lt;/p>
&lt;p>then the encoded data would be comprised of the following segments:&lt;/p>
&lt;ul>
&lt;li>DeltaEncoding(5, 5, 6, 6) (the string lengths)&lt;/li>
&lt;li>&amp;ldquo;HelloWorldFoobarABCDEF&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;h3 id="delta-strings-delta_byte_array--7">Delta Strings: (DELTA_BYTE_ARRAY = 7)&lt;/h3>
&lt;p>Supported Types: BYTE_ARRAY, FIXED_LEN_BYTE_ARRAY&lt;/p>
&lt;p>This is also known as incremental encoding or front compression: for each element in a
sequence of strings, store the prefix length of the previous entry plus the suffix.&lt;/p>
&lt;p>For a longer description, see &lt;a href="https://en.wikipedia.org/wiki/Incremental_encoding">https://en.wikipedia.org/wiki/Incremental_encoding&lt;/a>.&lt;/p>
&lt;p>This is stored as a sequence of delta-encoded prefix lengths (DELTA_BINARY_PACKED), followed by
the suffixes encoded as delta length byte arrays (DELTA_LENGTH_BYTE_ARRAY).&lt;/p>
&lt;p>For example, if the data was &amp;ldquo;axis&amp;rdquo;, &amp;ldquo;axle&amp;rdquo;, &amp;ldquo;babble&amp;rdquo;, &amp;ldquo;babyhood&amp;rdquo;&lt;/p>
&lt;p>then the encoded data would be comprised of the following segments:&lt;/p>
&lt;ul>
&lt;li>DeltaEncoding(0, 2, 0, 3) (the prefix lengths)&lt;/li>
&lt;li>DeltaEncoding(4, 2, 6, 5) (the suffix lengths)&lt;/li>
&lt;li>&amp;ldquo;axislebabbleyhood&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>Note that, even for FIXED_LEN_BYTE_ARRAY, all lengths are encoded despite the redundancy.&lt;/p>
&lt;h3 id="byte-stream-split-byte_stream_split--9">Byte Stream Split: (BYTE_STREAM_SPLIT = 9)&lt;/h3>
&lt;p>Supported Types: FLOAT, DOUBLE&lt;/p>
&lt;p>This encoding does not reduce the size of the data but can lead to a significantly better
compression ratio and speed when a compression algorithm is used afterwards.&lt;/p>
&lt;p>This encoding creates K byte-streams of length N where K is the size in bytes of the data
type and N is the number of elements in the data sequence. Specifically, K is 4 for FLOAT
type and 8 for DOUBLE type.
The bytes of each value are scattered to the corresponding streams. The 0-th byte goes to the
0-th stream, the 1-st byte goes to the 1-st stream and so on.
The streams are concatenated in the following order: 0-th stream, 1-st stream, etc.
The total length of encoded streams is K * N bytes. Because it does not have any metadata
to indicate the total length, the end of the streams is also the end of data page. No padding
is allowed inside the data page.&lt;/p>
&lt;p>Example:
Original data is three 32-bit floats and for simplicity we look at their raw representation.&lt;/p>
&lt;pre tabindex="0">&lt;code> Element 0 Element 1 Element 2
Bytes AA BB CC DD 00 11 22 33 A3 B4 C5 D6
&lt;/code>&lt;/pre>&lt;p>After applying the transformation, the data has the following representation:&lt;/p>
&lt;pre tabindex="0">&lt;code>Bytes AA 00 A3 BB 11 B4 CC 22 C5 DD 33 D6
&lt;/code>&lt;/pre></description></item><item><title>Docs: Parquet Modular Encryption</title><link>/docs/file-format/data-pages/encryption/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/encryption/</guid><description>
&lt;p>Parquet files containing sensitive information can be protected by the modular encryption
mechanism that encrypts and authenticates the file data and metadata - while allowing
for a regular Parquet functionality (columnar projection, predicate pushdown, encoding
and compression).&lt;/p>
&lt;h2 id="1-problem-statement">1 Problem Statement&lt;/h2>
&lt;p>Existing data protection solutions (such as flat encryption of files, in-storage encryption,
or use of an encrypting storage client) can be applied to Parquet files, but have various
security or performance issues. An encryption mechanism, integrated in the Parquet format,
allows for an optimal combination of data security, processing speed and encryption granularity.&lt;/p>
&lt;h2 id="2-goals">2 Goals&lt;/h2>
&lt;ol>
&lt;li>Protect Parquet data and metadata by encryption, while enabling selective reads
(columnar projection, predicate push-down).&lt;/li>
&lt;li>Implement &amp;ldquo;client-side&amp;rdquo; encryption/decryption (storage client). The storage server
must not see plaintext data, metadata or encryption keys.&lt;/li>
&lt;li>Leverage authenticated encryption that allows clients to check integrity of the retrieved
data - making sure the file (or file parts) have not been replaced with a wrong version, or
tampered with otherwise.&lt;/li>
&lt;li>Enable different encryption keys for different columns and for the footer.&lt;/li>
&lt;li>Allow for partial encryption - encrypt only column(s) with sensitive data.&lt;/li>
&lt;li>Work with all compression and encoding mechanisms supported in Parquet.&lt;/li>
&lt;li>Support multiple encryption algorithms, to account for different security and performance
requirements.&lt;/li>
&lt;li>Enable two modes for metadata protection -
&lt;ul>
&lt;li>full protection of file metadata&lt;/li>
&lt;li>partial protection of file metadata that allows legacy readers to access unencrypted
columns in an encrypted file.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Minimize overhead of encryption - in terms of size of encrypted files, and throughput
of write/read operations.&lt;/li>
&lt;/ol>
&lt;h2 id="3-technical-approach">3 Technical Approach&lt;/h2>
&lt;p>Parquet files are comprised of separately serialized components: pages, page headers, column
indexes, offset indexes, bloom filter headers and bitsets, the footer. Parquet encryption
mechanism denotes them as “modules”
and encrypts each module separately – making it possible to fetch and decrypt the footer,
find the offset of required pages, fetch the pages and decrypt the data. In this document,
the term “footer” always refers to the regular Parquet footer - the &lt;code>FileMetaData&lt;/code> structure,
and its nested fields (row groups / column chunks).&lt;/p>
&lt;p>File encryption is flexible - each column and the footer can be encrypted with the same key,
with a different key, or not encrypted at all.&lt;/p>
&lt;p>The results of compression of column pages are encrypted before being written to the output
stream. A new Thrift structure, with column crypto metadata, is added to column chunks of
the encrypted columns. This metadata provides information about the column encryption keys.&lt;/p>
&lt;p>The results of serialization of Thrift structures are encrypted, before being written
to the output stream.&lt;/p>
&lt;p>The file footer can be either encrypted or left as a plaintext. In an encrypted footer mode,
a new Thrift structure with file crypto metadata is added to the file. This metadata provides
information about the file encryption algorithm and the footer encryption key.&lt;/p>
&lt;p>In a plaintext footer mode, the contents of the footer structure is visible and signed
in order to verify its integrity. New footer fields keep an
information about the file encryption algorithm and the footer signing key.&lt;/p>
&lt;p>For encrypted columns, the following modules are always encrypted, with the same column key:
pages and page headers (both dictionary and data), column indexes, offset indexes, bloom filter
headers and bitsets. If the
column key is different from the footer encryption key, the column metadata is serialized
separately and encrypted with the column key. In this case, the column metadata is also
considered to be a module.&lt;/p>
&lt;h2 id="4-encryption-algorithms-and-keys">4 Encryption Algorithms and Keys&lt;/h2>
&lt;p>Parquet encryption algorithms are based on the standard AES ciphers for symmetric encryption.
AES is supported in Intel and other CPUs with hardware acceleration of crypto operations
(“AES-NI”) - that can be leveraged, for example, by Java programs (automatically via HotSpot),
or C++ programs (via EVP-* functions in OpenSSL). Parquet supports all standard AES key sizes:
128, 192 and 256 bits.&lt;/p>
&lt;p>Initially, two algorithms have been implemented, one based on a GCM mode of AES, and the
other on a combination of GCM and CTR modes.&lt;/p>
&lt;h3 id="41-aes-modes-used-in-parquet">4.1 AES modes used in Parquet&lt;/h3>
&lt;h4 id="411-aes-gcm">4.1.1 AES GCM&lt;/h4>
&lt;p>AES GCM is an authenticated encryption. Besides the data confidentiality (encryption), it
supports two levels of integrity verification (authentication): of the data (default),
and of the data combined with an optional AAD (“additional authenticated data”). The
authentication allows to make sure the data has not been tampered with. An AAD
is a free text to be authenticated, together with the data. The user can, for example, pass the
file name with its version (or creation timestamp) as an AAD input, to verify that the
file has not been replaced with an older version. The details on how Parquet creates
and uses AADs are provided in the section 4.4.&lt;/p>
&lt;h4 id="412-aes-ctr">4.1.2 AES CTR&lt;/h4>
&lt;p>AES CTR is a regular (not authenticated) cipher. It is faster than the GCM cipher, since it
doesn’t perform integrity verification and doesn’t calculate an authentication tag.
Actually, GCM is a combination of the CTR cipher and an
authentication layer called GMAC. For applications running without AES acceleration
(e.g. on Java versions before Java 9) and willing to compromise on content verification,
CTR cipher can provide a boost in encryption/decryption throughput.&lt;/p>
&lt;h4 id="413-nonces-and-ivs">4.1.3 Nonces and IVs&lt;/h4>
&lt;p>GCM and CTR ciphers require a unique vector to be provided for each encrypted stream.
In this document, the unique input to GCM encryption is called nonce (“number used once”).
The unique input to CTR encryption is called IV (&amp;ldquo;initialization vector&amp;rdquo;), and is comprised of two
parts: a nonce and an initial counter field.&lt;/p>
&lt;p>Parquet encryption uses the RBG-based (random bit generator) nonce construction as defined in
the section 8.2.2 of the NIST SP 800-38D document. For each encrypted module, Parquet generates a
unique nonce with a length of 12 bytes (96 bits). Notice: the NIST
specification uses a term “IV” for what is called “nonce” in the Parquet encryption design.&lt;/p>
&lt;h3 id="42-parquet-encryption-algorithms">4.2 Parquet encryption algorithms&lt;/h3>
&lt;h4 id="421-aes_gcm_v1">4.2.1 AES_GCM_V1&lt;/h4>
&lt;p>This Parquet algorithm encrypts all modules by the GCM cipher, without padding. The AES GCM cipher
must be implemented by a cryptographic provider according to the NIST SP 800-38D specification.&lt;/p>
&lt;p>In Parquet, an input to the GCM cipher is an encryption key, a 12-byte nonce, a plaintext and an
AAD. The output is a ciphertext with the length equal to that of plaintext, and a 16-byte authentication
tag used to verify the ciphertext and AAD integrity.&lt;/p>
&lt;h4 id="422-aes_gcm_ctr_v1">4.2.2 AES_GCM_CTR_V1&lt;/h4>
&lt;p>In this Parquet algorithm, all modules except pages are encrypted with the GCM cipher, as described
above. The pages are encrypted by the CTR cipher without padding. This allows to encrypt/decrypt
the bulk of the data faster, while still verifying the metadata integrity and making
sure the file has not been replaced with a wrong version. However, tampering with the
page data might go unnoticed. The AES CTR cipher
must be implemented by a cryptographic provider according to the NIST SP 800-38A specification.&lt;/p>
&lt;p>In Parquet, an input to the CTR cipher is an encryption key, a 16-byte IV and a plaintext. IVs are comprised of
a 12-byte nonce and a 4-byte initial counter field. The first 31 bits of the initial counter field are set
to 0, the last bit is set to 1. The output is a ciphertext with the length equal to that of plaintext.&lt;/p>
&lt;h3 id="43-key-metadata">4.3 Key metadata&lt;/h3>
&lt;p>A wide variety of services and tools for management of encryption keys exist in the
industry today. Public clouds offer different key management services (KMS), and
organizational IT systems either build proprietary key managers in-house or adopt open source
tools for on-premises deployment. Besides the diversity of management tools, there are many
ways to generate and handle the keys themselves (generate Data keys inside KMS – or locally
upon data encryption; use Data keys only, or use Master keys to encrypt the Data keys;
store the encrypted key material inside the data file, or at a separate location; etc). There
is also a large variety of authorization and certification methods, required to control the
access to encryption keys.&lt;/p>
&lt;p>Parquet is not limited to a single KMS, key generation/wrapping method, or authorization service.
Instead, Parquet provides a developer with a simple interface that can be utilized for implementation
of any key management scheme. For each column or footer key, a file writer can generate and pass an
arbitrary &lt;code>key_metadata&lt;/code> byte array that will be stored in the file. This field is made available to
file readers to enable recovery of the key. For example, the key_metadata
can keep a serialized&lt;/p>
&lt;ul>
&lt;li>String ID of a Data key. This enables direct retrieval of the Data key from a KMS.&lt;/li>
&lt;li>Encrypted Data key, and string ID of a Master key. The Data key is generated randomly and
encrypted with a Master key either remotely in a KMS, or locally after retrieving the Master key from a KMS.
Master key rotation requires modification of the data file footer.&lt;/li>
&lt;li>Short ID (counter) of a Data key inside the Parquet data file. The Data key is encrypted with a
Master key using one of the options described above – but the resulting key material is stored
separately, outside the data file, and will be retrieved using the counter and file path.
Master key rotation doesn&amp;rsquo;t require modification of the data file.&lt;/li>
&lt;/ul>
&lt;p>Key metadata can also be empty - in a case the encryption keys are fully managed by the caller
code, and passed explicitly to Parquet readers for the file footer and each encrypted column.&lt;/p>
&lt;h3 id="44-additional-authenticated-data">4.4 Additional Authenticated Data&lt;/h3>
&lt;p>The AES GCM cipher protects against byte replacement inside a ciphertext - but, without an AAD,
it can&amp;rsquo;t prevent replacement of one ciphertext with another (encrypted with the same key).
Parquet modular encryption leverages AADs to protect against swapping ciphertext modules (encrypted
with AES GCM) inside a file or between files. Parquet can also protect against swapping full
files - for example, replacement of a file with an old version, or replacement of one table
partition with another. AADs are built to reflects the identity of a file and of the modules
inside the file.&lt;/p>
&lt;p>Parquet constructs a module AAD from two components: an optional AAD prefix - a string provided
by the user for the file, and an AAD suffix, built internally for each GCM-encrypted module
inside the file. The AAD prefix should reflect the target identity that helps to detect file
swapping (a simple example - table name with a date and partition, e.g. &amp;ldquo;employees_23May2018.part0&amp;rdquo;).
The AAD suffix reflects the internal identity of modules inside the file, which for example
prevents replacement of column pages in row group 0 by pages from the same column in row
group 1. The module AAD is a direct concatenation of the prefix and suffix parts.&lt;/p>
&lt;h4 id="441-aad-prefix">4.4.1 AAD prefix&lt;/h4>
&lt;p>File swapping can be prevented by an AAD prefix string, that uniquely identifies the file and
allows to differentiate it e.g. from older versions of the file or from other partition files in the same
data set (table). This string is optionally passed by a writer upon file creation. If provided,
the AAD prefix is stored in an &lt;code>aad_prefix&lt;/code> field in the file, and is made available to the readers.
This field is not encrypted. If a user is concerned about keeping the file identity inside the file,
the writer code can explicitly request Parquet not to store the AAD prefix. Then the aad_prefix field
will be empty; AAD prefixes must be fully managed by the caller code and supplied explictly to Parquet
readers for each file.&lt;/p>
&lt;p>The protection against swapping full files is optional. It is not enabled by default because
it requires the writers to generate and pass an AAD prefix.&lt;/p>
&lt;p>A reader of a file created with an AAD prefix, should be able to verify the prefix (file identity)
by comparing it with e.g. the target table name, using a convention accepted in the organization.
Readers of data sets, comprised of multiple partition files, can verify data set integrity by
checking the number of files and the AAD prefix of each file. For example, a reader that needs to
process the employee table, a May 23 version, knows (via the convention) that
the AAD prefix must be &amp;ldquo;employees_23May2018.partN&amp;rdquo; in
each corresponding table file. If a file AAD prefix is &amp;ldquo;employees_23May2018.part0&amp;rdquo;, the reader
will know it is fine, but if the prefix is &amp;ldquo;employees_23May2016.part0&amp;rdquo; or &amp;ldquo;contractors_23May2018.part0&amp;rdquo; -
the file is wrong. The reader should also know the number of table partitions and verify availability
of all partition files (prefixes) from 0 to N-1.&lt;/p>
&lt;h4 id="442-aad-suffix">4.4.2 AAD suffix&lt;/h4>
&lt;p>The suffix part of a module AAD protects against module swapping inside a file. It also protects against
module swapping between files - in situations when an encryption key is re-used in multiple files and the
writer has not provided a unique AAD prefix for each file.&lt;/p>
&lt;p>Unlike AAD prefix, a suffix is built internally by Parquet, by direct concatenation of the following parts:&lt;/p>
&lt;ol>
&lt;li>[All modules] internal file identifier - a random byte array generated for each file (implementation-defined length)&lt;/li>
&lt;li>[All modules] module type (1 byte)&lt;/li>
&lt;li>[All modules except footer] row group ordinal (2 byte short, little endian)&lt;/li>
&lt;li>[All modules except footer] column ordinal (2 byte short, little endian)&lt;/li>
&lt;li>[Data page and header only] page ordinal (2 byte short, little endian)&lt;/li>
&lt;/ol>
&lt;p>The following module types are defined:&lt;/p>
&lt;ul>
&lt;li>Footer (0)&lt;/li>
&lt;li>ColumnMetaData (1)&lt;/li>
&lt;li>Data Page (2)&lt;/li>
&lt;li>Dictionary Page (3)&lt;/li>
&lt;li>Data PageHeader (4)&lt;/li>
&lt;li>Dictionary PageHeader (5)&lt;/li>
&lt;li>ColumnIndex (6)&lt;/li>
&lt;li>OffsetIndex (7)&lt;/li>
&lt;li>BloomFilter Header (8)&lt;/li>
&lt;li>BloomFilter Bitset (9)&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Internal File ID&lt;/th>
&lt;th>Module type&lt;/th>
&lt;th>Row group ordinal&lt;/th>
&lt;th>Column ordinal&lt;/th>
&lt;th>Page ordinal&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Footer&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (0)&lt;/td>
&lt;td>no&lt;/td>
&lt;td>no&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ColumnMetaData&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (1)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Data Page&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (2)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Dictionary Page&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (3)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Data PageHeader&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (4)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Dictionary PageHeader&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (5)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ColumnIndex&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (6)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OffsetIndex&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (7)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BloomFilter Header&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (8)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BloomFilter Bitset&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes (9)&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>yes&lt;/td>
&lt;td>no&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="5-file-format">5 File Format&lt;/h2>
&lt;h3 id="51-encrypted-module-serialization">5.1 Encrypted module serialization&lt;/h3>
&lt;p>All modules, except column pages, are encrypted with the GCM cipher. In the AES_GCM_V1 algorithm,
the column pages are also encrypted with AES GCM. For each module, the GCM encryption
buffer is comprised of a nonce, ciphertext and tag, described in the Algorithms section. The length of
the encryption buffer (a 4-byte little endian) is written to the output stream, followed by the buffer itself.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>length (4 bytes)&lt;/th>
&lt;th>nonce (12 bytes)&lt;/th>
&lt;th>ciphertext (length-28 bytes)&lt;/th>
&lt;th>tag (16 bytes)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>In the AES_GCM_CTR_V1 algorithm, the column pages are encrypted with AES CTR.
For each page, the CTR encryption buffer is comprised of a nonce and ciphertext,
described in the Algorithms section. The length of the encryption buffer
(a 4-byte little endian) is written to the output stream, followed by the buffer itself.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>length (4 bytes)&lt;/th>
&lt;th>nonce (12 bytes)&lt;/th>
&lt;th>ciphertext (length-12 bytes)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;h3 id="52-crypto-structures">5.2 Crypto structures&lt;/h3>
&lt;p>Parquet file encryption algorithm is specified in a union of the following Thrift structures:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">AesGcmV1&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** AAD prefix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">aad_prefix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Unique file identifier part of AAD suffix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">aad_file_unique&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** In files encrypted with AAD prefix without storing it,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * readers must supply the prefix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">supply_aad_prefix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">AesGcmCtrV1&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** AAD prefix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">aad_prefix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Unique file identifier part of AAD suffix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">aad_file_unique&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** In files encrypted with AAD prefix without storing it,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * readers must supply the prefix **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span> &lt;span style="color:#000">supply_aad_prefix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">union&lt;/span> &lt;span style="color:#000">EncryptionAlgorithm&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">AesGcmV1&lt;/span> &lt;span style="color:#000">AES_GCM_V1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">AesGcmCtrV1&lt;/span> &lt;span style="color:#000">AES_GCM_CTR_V1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If a writer provides an AAD prefix, it will be used for enciphering the file and stored in the
&lt;code>aad_prefix&lt;/code> field. However, the writer can request Parquet not to store the prefix in the file. In
this case, the &lt;code>aad_prefix&lt;/code> field will not be set, and the &lt;code>supply_aad_prefix&lt;/code> field will be set
to &lt;em>true&lt;/em> to inform readers they must supply the AAD prefix for this file in order to be able to
decrypt it.&lt;/p>
&lt;p>The row group ordinal, required for AAD suffix calculation, is set in the RowGroup structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">RowGroup&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Row group ordinal in the file **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">7&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">i16&lt;/span> &lt;span style="color:#000">ordinal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A &lt;code>crypto_metadata&lt;/code> field is set in each ColumnChunk in the encrypted columns. ColumnCryptoMetaData
is a union - the actual structure is chosen depending on whether the column is encrypted with the
footer encryption key, or with a column-specific key. For the latter, a key metadata can be specified.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">EncryptionWithFooterKey&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">EncryptionWithColumnKey&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Column path in schema **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">required&lt;/span> &lt;span style="color:#000">list&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">string&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000">path_in_schema&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Retrieval metadata of column encryption key **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">key_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">union&lt;/span> &lt;span style="color:#000">ColumnCryptoMetaData&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">EncryptionWithFooterKey&lt;/span> &lt;span style="color:#000">ENCRYPTION_WITH_FOOTER_KEY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">EncryptionWithColumnKey&lt;/span> &lt;span style="color:#000">ENCRYPTION_WITH_COLUMN_KEY&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">ColumnChunk&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Crypto metadata of encrypted columns **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">ColumnCryptoMetaData&lt;/span> &lt;span style="color:#000">crypto_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="53-protection-of-sensitive-metadata">5.3 Protection of sensitive metadata&lt;/h3>
&lt;p>The Parquet file footer, and its nested structures, contain sensitive information - ranging
from a secret data (column statistics) to other information that can be exploited by an
attacker (e.g. schema, num_values, key_value_metadata, encoding
and crypto_metadata). This information is automatically protected when the footer and
secret columns are encrypted with the same key. In other cases - when column(s) and the
footer are encrypted with different keys; or column(s) are encrypted and the footer is not,
an extra measure is required to protect the column-specific information in the file footer.
In these cases, the &lt;code>ColumnMetaData&lt;/code> structures are Thrift-serialized separately and encrypted
with a column-specific key, thus protecting the column stats and
other metadata. The column metadata module is encrypted with the GCM cipher, serialized
according to the section 5.1 instructions and stored in an &lt;code>optional binary encrypted_column_metadata&lt;/code>
field in the &lt;code>ColumnChunk&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">ColumnChunk&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Column metadata for this chunk.. **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">ColumnMetaData&lt;/span> &lt;span style="color:#000">meta_data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">..&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Crypto metadata of encrypted columns **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">ColumnCryptoMetaData&lt;/span> &lt;span style="color:#000">crypto_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Encrypted column metadata for this chunk **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">9&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">encrypted_column_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="54-encrypted-footer-mode">5.4 Encrypted footer mode&lt;/h3>
&lt;p>In files with sensitive column data, a good security practice is to encrypt not only the
secret columns, but also the file footer metadata. This hides the file schema,
number of rows, key-value properties, column sort order, names of the encrypted columns
and metadata of the column encryption keys.&lt;/p>
&lt;p>The columns encrypted with the same key as the footer must leave the column metadata at the original
location, &lt;code>optional ColumnMetaData meta_data&lt;/code> in the &lt;code>ColumnChunk&lt;/code> structure.
This field is not set for columns encrypted with a column-specific key - instead, the &lt;code>ColumnMetaData&lt;/code>
is Thrift-serialized, encrypted with the column key and written to the &lt;code>encrypted_column_metadata&lt;/code>
field in the &lt;code>ColumnChunk&lt;/code> structure, as described in the section 5.3.&lt;/p>
&lt;p>A Thrift-serialized &lt;code>FileCryptoMetaData&lt;/code> structure is written before the encrypted footer.
It contains information on the file encryption algorithm and on the footer key metadata. Then
the combined length of this structure and of the encrypted footer is written as a 4-byte
little endian integer, followed by a final magic string, &amp;ldquo;PARE&amp;rdquo;. The same magic bytes are
written at the beginning of the file (offset 0). Parquet readers start file parsing by
reading and checking the magic string. Therefore, the encrypted footer mode uses a new
magic string (&amp;ldquo;PARE&amp;rdquo;) in order to instruct readers to look for a file crypto metadata
before the footer - and also to immediately inform legacy readers (expecting ‘PAR1’
bytes) that they can’t parse this file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">/** Crypto metadata for files with encrypted footer **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">FileCryptoMetaData&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * Encryption algorithm. This field is only used for files
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * with encrypted footer. Files with plaintext footer store algorithm id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * inside footer (FileMetaData structure).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">required&lt;/span> &lt;span style="color:#000">EncryptionAlgorithm&lt;/span> &lt;span style="color:#000">encryption_algorithm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/** Retrieval metadata of key used for encryption of footer,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * and (possibly) columns **/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">key_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img alt="File Layout - Encrypted footer" src="/images/FileLayoutEncryptionEF.png">&lt;/p>
&lt;h3 id="55-plaintext-footer-mode">5.5 Plaintext footer mode&lt;/h3>
&lt;p>This mode allows legacy Parquet versions (released before the encryption support) to access
unencrypted columns in encrypted files - at a price of leaving certain metadata fields
unprotected in these files.&lt;/p>
&lt;p>The plaintext footer mode can be useful during a transitional period in organizations where
some frameworks can&amp;rsquo;t be upgraded to a new Parquet library for a while. Data writers will
upgrade and run with a new Parquet version, producing encrypted files in this mode. Data
readers working with sensitive data will also upgrade to a new Parquet library. But other
readers that don&amp;rsquo;t need the sensitive columns, can continue working with an older Parquet
version. They will be able to access plaintext columns in encrypted files. A legacy reader,
trying to access a sensitive column data in an encrypted file with a plaintext footer, will
get an exception. More specifically, a Thrift parsing exception on an encrypted page header
structure. Again, using legacy Parquet readers for encrypted files is a temporary solution.&lt;/p>
&lt;p>In the plaintext footer mode, the &lt;code>optional ColumnMetaData meta_data&lt;/code> is set in the &lt;code>ColumnChunk&lt;/code>
structure for all columns, but is stripped of the statistics for the sensitive (encrypted)
columns. These statistics are available for new readers with the column key - they decrypt
the &lt;code>encrypted_column_metadata&lt;/code> field, described in the section 5.3, and parse it to get statistics
and all other column metadata values. The legacy readers are not aware of the encrypted metadata field;
they parse the regular (plaintext) field as usual. While they can&amp;rsquo;t read the data of encrypted
columns, they read their metadata to extract the offset and size of encrypted column data,
required for column chunk vectorization.&lt;/p>
&lt;p>The plaintext footer is signed in order to prevent tampering with the
&lt;code>FileMetaData&lt;/code> contents. The footer signing is done by encrypting the serialized &lt;code>FileMetaData&lt;/code>
structure with the
AES GCM algorithm - using a footer signing key, and an AAD constructed according to the instructions
of the section 4.4. Only the nonce and GCM tag are stored in the file – as a 28-byte
fixed-length array, written right after the footer itself. The ciphertext is not stored,
because it is not required for footer integrity verification by readers.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>nonce (12 bytes)&lt;/th>
&lt;th>tag (16 bytes)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>The plaintext footer mode sets the following fields in the the FileMetaData structure:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">FileMetaData&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * Encryption algorithm. This field is set only in encrypted files
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * with plaintext footer. Files with encrypted footer store algorithm id
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * in FileCryptoMetaData structure.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">EncryptionAlgorithm&lt;/span> &lt;span style="color:#000">encryption_algorithm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * Retrieval metadata of key used for signing the footer.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> * Used only in encrypted files with plaintext footer.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">9&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#000">optional&lt;/span> &lt;span style="color:#000">binary&lt;/span> &lt;span style="color:#000">footer_signing_key_metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>FileMetaData&lt;/code> structure is Thrift-serialized and written to the output stream.
The 28-byte footer signature is written after the plaintext footer, followed by a 4-byte little endian integer
that contains the combined length of the footer and its signature. A final magic string,
&amp;ldquo;PAR1&amp;rdquo;, is written at the end of the
file. The same magic string is written at the beginning of the file (offset 0). The magic bytes
for plaintext footer mode are ‘PAR1’ to allow legacy readers to read projections of the file
that do not include encrypted columns.&lt;/p>
&lt;p>&lt;img alt="File Layout - Encrypted footer" src="/images/FileLayoutEncryptionPF.png">&lt;/p>
&lt;h2 id="6-encryption-overhead">6. Encryption Overhead&lt;/h2>
&lt;p>The size overhead of Parquet modular encryption is negligible, since most of the encryption
operations are performed on pages (the minimal unit of Parquet data storage and compression).
The overhead order of magnitude is adding 1 byte per each ~30,000 bytes of original
data - calculated by comparing the page encryption overhead (nonce + tag + length = 32 bytes)
to the default page size (1 MB). This is a rough estimation, and can change with the encryption
algorithm (no 16-byte tag in AES_GCM_CTR_V1) and with page configuration or data encoding/compression.&lt;/p>
&lt;p>The throughput overhead of Parquet modular encryption depends on whether AES enciphering is
done in software or hardware. In both cases, performing encryption on full pages (~1MB buffers)
instead of on much smaller individual data values causes AES to work at its maximal speed.&lt;/p></description></item><item><title>Docs: Checksumming</title><link>/docs/file-format/data-pages/checksumming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/checksumming/</guid><description>
&lt;p>Pages of all kinds can be individually checksummed. This allows disabling of checksums
at the HDFS file level, to better support single row lookups. Checksums are calculated
using the standard CRC32 algorithm - as used in e.g. GZip - on the serialized binary
representation of a page (not including the page header itself).&lt;/p></description></item><item><title>Docs: Column Chunks</title><link>/docs/file-format/data-pages/columnchunks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/columnchunks/</guid><description>
&lt;p>Column chunks are composed of pages written back to back. The pages share a common
header and readers can skip over pages they are not interested in. The data for the
page follows the header and can be compressed and/or encoded. The compression and
encoding is specified in the page metadata.&lt;/p>
&lt;p>A column chunk might be partly or completely dictionary encoded. It means that
dictionary indexes are saved in the data pages instead of the actual values. The
actual values are stored in the dictionary page. See details in Encodings.md.
The dictionary page must be placed at the first position of the column chunk. At
most one dictionary page can be placed in a column chunk.&lt;/p>
&lt;p>Additionally, files can contain an optional column index to allow readers to
skip pages more efficiently. See PageIndex.md for details and
the reasoning behind adding these to the format.&lt;/p></description></item><item><title>Docs: Error Recovery</title><link>/docs/file-format/data-pages/errorrecovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/file-format/data-pages/errorrecovery/</guid><description>
&lt;p>If the file metadata is corrupt, the file is lost. If the column metadata is corrupt,
that column chunk is lost (but column chunks for this column in other row groups are
okay). If a page header is corrupt, the remaining pages in that chunk are lost. If
the data within a page is corrupt, that page is lost. The file will be more
resilient to corruption with smaller row groups.&lt;/p>
&lt;p>Potential extension: With smaller row groups, the biggest issue is placing the file
metadata at the end. If an error happens while writing the file metadata, all the
data written will be unreadable. This can be fixed by writing the file metadata
every Nth row group.
Each file metadata would be cumulative and include all the row groups written so
far. Combining this with the strategy used for rc or avro files using sync markers,
a reader could recover partially written files.&lt;/p></description></item></channel></rss>